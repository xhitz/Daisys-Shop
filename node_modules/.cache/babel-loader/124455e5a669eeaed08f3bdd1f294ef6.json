{"ast":null,"code":"// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\nvar Bytes = require(\"./bytes\");\n\nvar Nat = require(\"./nat\");\n\nvar keccak256s = require(\"./hash\").keccak256s; // (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\n\n\nvar encode = function encode(type, value) {\n  if (type === \"bytes\") {\n    var length = Bytes.length(value);\n    var nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    var lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    var bytesEncoded = Bytes.padRight(nextMul32, value);\n    return {\n      data: Bytes.concat(lengthEncoded, bytesEncoded),\n      dynamic: true\n    };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return {\n      data: Bytes.pad(32, value),\n      dynamic: false\n    };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n}; // (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\n\n\nvar methodData = function methodData(method, params) {\n  var methodSig = method.name + \"(\" + method.inputs.map(function (i) {\n    return i.type;\n  }).join(\",\") + \")\";\n  var methodHash = keccak256s(methodSig).slice(0, 10);\n  var encodedParams = params.map(function (param, i) {\n    return encode(method.inputs[i].type, param);\n  });\n  var headBlock = \"0x\";\n  var dataBlock = \"0x\";\n\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\n\nmodule.exports = {\n  encode: encode,\n  methodData: methodData\n};","map":{"version":3,"sources":["/Users/crypto/Daisys/node_modules/eth-lib/lib/abi.js"],"names":["Bytes","require","Nat","keccak256s","encode","type","value","length","nextMul32","lengthEncoded","fromNumber","data","bytesEncoded","padRight","concat","dynamic","pad","methodData","method","params","methodSig","name","inputs","map","i","join","methodHash","slice","encodedParams","param","headBlock","dataBlock","dataLoc","flatten","module","exports"],"mappings":"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","sourcesContent":["// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\n\nconst Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst keccak256s = require(\"./hash\").keccak256s;\n\n// (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\nconst encode = (type, value) => {\n  if (type === \"bytes\") {\n    const length = Bytes.length(value);\n    const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    const lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    const bytesEncoded = Bytes.padRight(nextMul32, value);\n    return { data: Bytes.concat(lengthEncoded, bytesEncoded), dynamic: true };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return { data: Bytes.pad(32, value), dynamic: false };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n};\n\n// (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\nconst methodData = (method, params) => {\n  const methodSig = method.name + \"(\" + method.inputs.map(i => i.type).join(\",\") + \")\";\n  const methodHash = keccak256s(methodSig).slice(0, 10);\n  let encodedParams = params.map((param, i) => encode(method.inputs[i].type, param));\n  var headBlock = \"0x\";\n  let dataBlock = \"0x\";\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\n\nmodule.exports = {\n  encode,\n  methodData\n};"]},"metadata":{},"sourceType":"script"}