{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"./crypto\");\n\nconst bs58check = require('bs58check');\n\nconst ecc = require('tiny-secp256k1');\n\nconst typeforce = require('typeforce');\n\nconst wif = require('wif');\n\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n});\nconst BITCOIN = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\n\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null;\n}\n\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\n\nclass BIP32 {\n  constructor(__D, __Q, chainCode, network) {\n    let __DEPTH = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    let __INDEX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    let __PARENT_FINGERPRINT = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0x00000000;\n\n    this.__D = __D;\n    this.__Q = __Q;\n    this.chainCode = chainCode;\n    this.network = network;\n    this.__DEPTH = __DEPTH;\n    this.__INDEX = __INDEX;\n    this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n    typeforce(NETWORK_TYPE, network);\n    this.lowR = false;\n  }\n\n  get depth() {\n    return this.__DEPTH;\n  }\n\n  get index() {\n    return this.__INDEX;\n  }\n\n  get parentFingerprint() {\n    return this.__PARENT_FINGERPRINT;\n  }\n\n  get publicKey() {\n    if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);\n    return this.__Q;\n  }\n\n  get privateKey() {\n    return this.__D;\n  }\n\n  get identifier() {\n    return crypto.hash160(this.publicKey);\n  }\n\n  get fingerprint() {\n    return this.identifier.slice(0, 4);\n  } // Private === not neutered\n  // Public === neutered\n\n\n  isNeutered() {\n    return this.__D === undefined;\n  }\n\n  neutered() {\n    return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n  }\n\n  toBase58() {\n    const network = this.network;\n    const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n    const buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n    buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n    buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n    buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in big endian. (0x00000000 if master key)\n\n    buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n    this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n    if (!this.isNeutered()) {\n      // 0x00 + k for private keys\n      buffer.writeUInt8(0, 45);\n      this.privateKey.copy(buffer, 46); // 33 bytes: the public key\n    } else {\n      // X9.62 encoding for public keys\n      this.publicKey.copy(buffer, 45);\n    }\n\n    return bs58check.encode(buffer);\n  }\n\n  toWIF() {\n    if (!this.privateKey) throw new TypeError('Missing private key');\n    return wif.encode(this.network.wif, this.privateKey, true);\n  } // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\n  derive(index) {\n    typeforce(typeforce.UInt32, index);\n    const isHardened = index >= HIGHEST_BIT;\n    const data = Buffer.allocUnsafe(37); // Hardened child\n\n    if (isHardened) {\n      if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n      data[0] = 0x00;\n      this.privateKey.copy(data, 1);\n      data.writeUInt32BE(index, 33); // Normal child\n    } else {\n      // data = serP(point(kpar)) || ser32(index)\n      //      = serP(Kpar) || ser32(index)\n      this.publicKey.copy(data, 0);\n      data.writeUInt32BE(index, 33);\n    }\n\n    const I = crypto.hmacSHA512(this.chainCode, data);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32); // if parse256(IL) >= n, proceed with the next value for i\n\n    if (!ecc.isPrivate(IL)) return this.derive(index + 1); // Private parent key -> private child key\n\n    let hd;\n\n    if (!this.isNeutered()) {\n      // ki = parse256(IL) + kpar (mod n)\n      const ki = ecc.privateAdd(this.privateKey, IL); // In case ki == 0, proceed with the next value for i\n\n      if (ki == null) return this.derive(index + 1);\n      hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0)); // Public parent key -> public child key\n    } else {\n      // Ki = point(parse256(IL)) + Kpar\n      //    = G*IL + Kpar\n      const Ki = ecc.pointAddScalar(this.publicKey, IL, true); // In case Ki is the point at infinity, proceed with the next value for i\n\n      if (Ki === null) return this.derive(index + 1);\n      hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n    }\n\n    return hd;\n  }\n\n  deriveHardened(index) {\n    typeforce(UInt31, index); // Only derives hardened private keys by default\n\n    return this.derive(index + HIGHEST_BIT);\n  }\n\n  derivePath(path) {\n    typeforce(BIP32Path, path);\n    let splitPath = path.split('/');\n\n    if (splitPath[0] === 'm') {\n      if (this.parentFingerprint) throw new TypeError('Expected master, got child');\n      splitPath = splitPath.slice(1);\n    }\n\n    return splitPath.reduce((prevHd, indexStr) => {\n      let index;\n\n      if (indexStr.slice(-1) === `'`) {\n        index = parseInt(indexStr.slice(0, -1), 10);\n        return prevHd.deriveHardened(index);\n      } else {\n        index = parseInt(indexStr, 10);\n        return prevHd.derive(index);\n      }\n    }, this);\n  }\n\n  sign(hash, lowR) {\n    if (!this.privateKey) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n\n    if (lowR === false) {\n      return ecc.sign(hash, this.privateKey);\n    } else {\n      let sig = ecc.sign(hash, this.privateKey);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0; // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n      }\n\n      return sig;\n    }\n  }\n\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n\n}\n\nfunction fromBase58(inString, network) {\n  const buffer = bs58check.decode(inString);\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length');\n  network = network || BITCOIN; // 4 bytes: version bytes\n\n  const version = buffer.readUInt32BE(0);\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  const depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  const parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  const index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index'); // 32 bytes: the chain code\n\n  const chainCode = buffer.slice(13, 45);\n  let hd; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');\n    const k = buffer.slice(46, 78);\n    hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    const X = buffer.slice(45, 78);\n    hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n  }\n\n  return hd;\n}\n\nexports.fromBase58 = fromBase58;\n\nfunction fromPrivateKey(privateKey, chainCode, network) {\n  return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, {\n    privateKey,\n    chainCode\n  });\n  network = network || BITCOIN;\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');\n  return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromPublicKey(publicKey, chainCode, network) {\n  return fromPublicKeyLocal(publicKey, chainCode, network);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, {\n    publicKey,\n    chainCode\n  });\n  network = network || BITCOIN; // verify the X coordinate is a point on the curve\n\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');\n  return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromSeed(seed, network) {\n  typeforce(typeforce.Buffer, seed);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  network = network || BITCOIN;\n  const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return fromPrivateKey(IL, IR, network);\n}\n\nexports.fromSeed = fromSeed;","map":{"version":3,"sources":["/Users/crypto/GETSCHWIFTY/node_modules/bip32/src/bip32.js"],"names":["Object","defineProperty","exports","value","crypto","require","bs58check","ecc","typeforce","wif","UINT256_TYPE","BufferN","NETWORK_TYPE","compile","UInt8","bip32","public","UInt32","private","BITCOIN","messagePrefix","bech32","pubKeyHash","scriptHash","HIGHEST_BIT","UINT31_MAX","Math","pow","BIP32Path","String","match","UInt31","BIP32","constructor","__D","__Q","chainCode","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","lowR","depth","index","parentFingerprint","publicKey","undefined","pointFromScalar","privateKey","identifier","hash160","fingerprint","slice","isNeutered","neutered","fromPublicKeyLocal","toBase58","version","buffer","Buffer","allocUnsafe","writeUInt32BE","writeUInt8","copy","encode","toWIF","TypeError","derive","isHardened","data","I","hmacSHA512","IL","IR","isPrivate","hd","ki","privateAdd","fromPrivateKeyLocal","readUInt32BE","Ki","pointAddScalar","deriveHardened","derivePath","path","splitPath","split","reduce","prevHd","indexStr","parseInt","sign","hash","Error","sig","extraData","alloc","counter","writeUIntLE","signWithEntropy","verify","signature","fromBase58","inString","decode","length","readUInt8","k","X","fromPrivateKey","fromPublicKey","isPoint","fromSeed","seed","from"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n"]},"metadata":{},"sourceType":"script"}